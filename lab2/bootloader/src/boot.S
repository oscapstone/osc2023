/* ARMv8 Assembly Instruction */
/**

mov x0, x1
    sets: x0 = x1
ldr x0, <addr>
    load 32bits from <addr> to x0
ldr w0, <addr>
    load 64bits from <addr> to w0
cbz x0, <label>
    if x0 == 0, jump to <label>
cbnz x0, <label>
    if x0 != 0, jump to <label>
str x0 [x1] #8
    store x0 in addr<x1> then x1=x1+8
b   <label>
    jump to <label>
bl  <label>
    jump to <label> and copies bl's next instruction into link register
wfe
    Wait for event, core in low-power state (power on, clk off)

**/

// x0 is used for dtb physical address

.section ".text.boot"

// Define the global symbol _start.
.global _start

// The start of the program.
_start:
setup_stack:
    ldr     x1, =_stack_top   // Load the top of the stack into x1.
    mov     sp, x1            // Move the value of x1 to the stack pointer register (SP).

setup_bss:
    ldr     x1, =_bss_top     // Load the top of the BSS section into x1.
    ldr     w2, =_bss_size    // Load the size of the BSS section into w2.

init_bss:
    cbz     w2, run_main      // If the size of the BSS section is zero, skip to the run_main label.
    str     xzr, [x1], #8    // Store the value zero in the current address pointed to by x1 (the start of the BSS section), and increment the address by 8 bytes (since we are storing a 64-bit value).
    sub     w2, w2, #1       // Decrement the size of the BSS section by 1.
    cbnz    w2, init_bss     // If the size of the BSS section is not zero, jump back to the init_bss label.

run_main:
    ldr     x1, =_dtb        // Load the address of _dtb into x1.
    str     x0, [x1], #8     // Store the physical address of the device tree blob in _dtb.
    bl      main             // Branch to the main function.

proc_hang:
    wfe                      // Wait for event.
    b       proc_hang        // Branch to the proc_hang label.
/**
x0 被用作設備樹資料的物理地址
setup_stack：設定堆疊的起始地址
setup_bss：設定 BSS 區域的結束地址
init_bss：將 BSS 區域內的所有內存初始化為 0
run_main：跳轉到 main 函數的入口點，開始執行程序
proc_hang：進入無窮循環，等待事件發生
**/